# translators_LICM

## Отчет выполнил: студент группы 381906-1 Устюжанин Никита
***
# Loop-invariant code motion

## Конфигурация 

CPU: Intel Pentium 4415U
Instruction set: Intel® SSE4.1, Intel® SSE4.2

## Сравнение различных вариантов программ

Для сравнения возьмем licm_10.cpp.

В исходной версии видно, что сложения выполняются на каждой итерации цикла:
```
for.body:                                         ; preds = %for.cond
  %1 = load i32, i32* %a1.addr, align 4
  %2 = load i32, i32* %a2.addr, align 4
  %add = add nsw i32 %1, %2
  ...
```

Во второй версии все инвариантные вычисления вынесены за пределы цикла:
```
; Function Attrs: nofree norecurse nounwind uwtable writeonly
define dso_local void @_Z4funciiiiiiiiiiiiiiii(i32 %a1, i32 %a2, i32 %a3, i32 %a4, i32 %a5, i32 %a6, i32 %a7, i32 %a8, i32 %a9, i32 %a10, i32 %a11, i32 %a12, i32 %a13, i32 %a14, i32 %a15, i32 %a16) local_unnamed_addr #0 {
entry:
  %add = add nsw i32 %a2, %a1
  %add1 = add nsw i32 %a3, %a2
  %add4 = add nsw i32 %a4, %a3
  %add7 = add nsw i32 %a5, %a4
```
Также можем видеть, что произошла оптимизационная работа с регистрами, в исходной версии было:
```
@b1 = dso_local global [100000 x i32] zeroinitializer, align 16
```
После оптимизации стало:
```
@b1 = dso_local local_unnamed_addr global [100000 x i32] zeroinitializer, align 16
```
В версии с отключенным проходом LICM инвариантные вычисления остались в теле цикла, но при этом сохранилась оптимизационная работа с регистрами.

## Измерение времени выполнения

Каждая программа выполнялась 10 раз.

|       Файл         |         -O0, с          |        -O1, c       | -O1 с отключенным LICM, с |
|--------------------|-------------------------|---------------------|---------------------------|
|    licm_5.cpp      |     1,8299 +- 0,0293    |  1,3341 +- 0,0191   |    1,35186 +- 0,00602     |
|    licm_10.cpp     |    1,54312 +- 0,00819   |  1,3945 +- 0,0301   |     1,35422 +- 0,0203     |
|    licm_20.cpp     |     1,9181 +- 0,02091   | 1,87762 +- 0,00601  |    1,86938 +- 0,00599     |
|   licm_div_5.cpp   |   0,39434 +- 0,000921   |  0,6731 +- 0,00716  |    1,43215 +- 0,00319     |
|   licm_div_10.cpp  |    2,62636 +- 0,00539   | 0,68105 +- 0,00299  |    2,62674 +- 0,00585     |
|   licm_div_20.cpp  |     5,2133 +- 0,0519    | 1,89475 +- 0,0071   |     5,229  +- 0,0191      |

Как мы можем видеть, в большинстве случаев -O1 оптимизация с LICM проходом наиболее эффективная. Но в случае со сложением разница между второй и третьей версией довольно незначительная. Это объясняется тем, что операция ADD сама по себе не очень памятизатратная, в отличие от DIV. Поэтому оптимизационная работа с регистрами позволила третьей версии максимально приблизиться по эффективности ко второй. А вот в случае деления данный подход не сработал, поскольку, как уже было сказано выше, DIV требует гораздо больше ресурсов. И в результате, оптимизационная работа с регистрами только замедлила работу программы, причем чем больше переменных, тем дольше она выполняется. В первой и третьей версии даже видно, что зависимость времени от переменных прямо пропорциональна - при увеличении переменных в два раза, время выполнения так же увеличивается в два раза.
